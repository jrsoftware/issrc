<?xml version="1.0"?>
<!DOCTYPE yasyx SYSTEM "ysd.dtd" [
 <!ENTITY ob      "{">
 <!ENTITY cb      "}">
 <!ENTITY bs      "\">
 <!ENTITY sp      "&#160;">
 <!ENTITY dsp     "&#160;&#160;">
 <!ENTITY define  '<synel><link href="define">define</link></synel>'>
 <!ENTITY undef   '<synel><link href="undef">undef</link></synel>'>
 <!ENTITY dim     '<synel><link href="dim">dim</link></synel>'>
 <!ENTITY redim   '<synel><link href="dim">redim</link></synel>'>
 <!ENTITY emit    '<synel><link href="emit">emit</link></synel>'>
 <!ENTITY error   '<synel><link href="error">error</link></synel>'>
 <!ENTITY include '<synel><link href="include">include</link></synel>'>
 <!ENTITY insert  '<synel><link href="insert">insert</link></synel>'>
 <!ENTITY pragma  '<synel><link href="pragma">pragma</link></synel>'>
 <!ENTITY file    '<synel><link href="file">file</link></synel>'>
 <!ENTITY ifdef   '<synel><link href="ifdef">ifdef</link></synel>'>
 <!ENTITY ifndef  '<synel><link href="ifdef">ifndef</link></synel>'>
 <!ENTITY ifexist '<synel><link href="ifdef">ifexist</link></synel>'>
 <!ENTITY ifnexist '<synel><link href="ifdef">ifnexist</link></synel>'>
 <!ENTITY if      '<synel><link href="if">if</link></synel>'>
 <!ENTITY elif    '<synel><link href="if">elif</link></synel>'>
 <!ENTITY else    '<synel><link href="if">else</link></synel>'>
 <!ENTITY endif   '<synel><link href="if">endif</link></synel>'>
 <!ENTITY sub     '<synel><link href="sub">sub</link></synel>'>
 <!ENTITY endsub  '<synel><link href="sub">endsub</link></synel>'>
 <!ENTITY for     '<synel><link href="for">for</link></synel>'>
 <!ENTITY expr    '<synel>expr</synel>'> <!-- not a directive -->
 <!ENTITY curtrans '<link href="current-translation" popup="yes">current translation</link>'>
 <!ENTITY translation '<link href="translation" popup="yes">translation</link>'>
 <!ENTITY builtins '<link href="builtinsiss">ISPPBuiltins.iss file</link>'>
 <!ENTITY dash "&#8211;">
]>
<yasyx>
	<topic id="isppoverview">
		<title>Introduction</title>
		<description header="no">
			<para>Inno Setup Preprocessor (ISPP) is a preprocessor add-on for Inno Setup.</para>
			<para>The main purpose of ISPP is to automate compile-time tasks and decrease the probability of typos in your scripts. For example, you can declare an ISPP variable (compile-time variable) &dash; your application name, for instance &dash; and then use its value in several places of your script. If for some reason you need to change the name of your application, you'll have to change it only once in your script. Without ISPP, you would probably need to change all occurrences of your application name throughout the script (AppName, AppVerName, DefaultGroupName etc. <extlink href="ms-its:isetup.chm::/topic_setupsection.htm">[Setup] section</extlink> directives).</para>
			<para>Another example of using ISPP would be gathering version information from your application by reading the version info of an EXE file, and using it in AppVerName <extlink href="ms-its:isetup.chm::/topic_setupsection.htm">[Setup] section</extlink> directive or anywhere else. Without ISPP, you would have to modify your script each time version of your application changes.</para>
			<para>Also, conditional in- and exclusion of portions of script is made possible by ISPP: you can create one single script for different versions/levels of your applications (for example, trial versus fully functional).</para>
			<para>Finally, ISPP makes it possible to split long lines using a line spanning symbol.</para>
			<para>Note: ISPP works exclusively at compile-time, and has no run-time functionality.</para>
    </description>
		<subtopicstitle>All topics</subtopicstitle>
		<topic id="docconv">
			<title>Documentation Conventions</title>
			<section title="Directive syntax documenting conventions">
				<para>Directive usage syntax uses the following conventions.</para>
				<table>
					<tr><td><code>()</code></td><td>Group of tokens.</td></tr>
					<tr><td><code>[]</code></td><td>Optional token or group of tokens.</td></tr>
					<tr><td><code>|</code></td><td>Mutually exclusive tokens.</td></tr>
					<tr><td><code>...</code></td><td>Previous token or group of tokens can be repeated.</td></tr>
					<tr><td><code><b>token</b></code></td><td>Reserved word or symbol(s). Must be typed exactly as shown.</td></tr>
					<tr><td><code>&lt;token&gt;</code></td><td>Non-terminal. Its syntax is either shown before, or explained.</td></tr>
				</table>
			</section>
			<section title="Function prototypes documenting conventions">
				<para>Function prototypes are shown as function result type, function name and list of formal arguments in parentheses.</para>
				<para>Words <synel>int</synel>, <synel>str</synel>, <synel>any</synel>, and <synel>void</synel> are used to specify integer type, string type, any type, or null type (also referred to as nothing, void), respectively. Null type as function result means that function does not return any value.</para>
				<para>Question mark (<synel>?</synel>) after the type of an argument means that this argument is optional.</para>
			</section>
		</topic>
		<topic id="directives">
			<title>Directives</title>
 			<description header="no">
				<para>In ISPP directives can be used in two ways: simple or inline.</para>
				<para>Simple directives occupy a whole line and begin with the <synel>#</synel> symbol. For example the following defines a variable called <synel>MyAppName</synel>:</para>
				<pre>
					<line>#define MyAppName "My Program"</line>
				</pre>
				<para>Inline directives appear inside other lines and begin with <synel>{#</synel> and end with <synel>}</synel>. For example the following sets Inno Setup's <synel>AppName</synel> directive to the value of the previously defined variable:</para>
				<pre>
					<line>[Setup]</line>
					<line>AppName={#MyAppName}</line>
				</pre>
				<para>As seen in the above example it is not necessary to specify the name of the &emit; directive when it is used inline, so <synel>{#MyAppName}</synel> is short for <synel>{#emit MyAppName}</synel>.</para>
			</description>
			<subtopicstitle>Available directives</subtopicstitle>
			<topic id="define">
				<title>#define</title>
				<keywords><kwd>define</kwd></keywords>
				<syntax>
					<define id="define-directive">
						<variant><nt name="variable-definition"/></variant>
						<variant><nt name="macro-definition"/></variant>
						<variant><nt name="default-visibility-set"/></variant>
					</define>
					<define id="variable-definition">
						<group><nt name="define-dir-name"/></group><opt><nt name="locality"/></opt><nt>ident</nt><opt><nt name="index-spec"/></opt><opt><opt><txt>=</txt></opt><nt>expr</nt></opt>
					</define>
					<define id="macro-definition">
						<group><nt name="define-dir-name"/></group><opt><nt name="locality"/></opt><nt>ident</nt><txt>(</txt><opt><nt name="formal-macro-args"/></opt><txt>)</txt><nt>expr</nt>
					</define>
					<define id="default-visibility-set">
						<group><nt name="define-dir-name"/></group><nt name="locality"/>
					</define>
					<define id="define-dir-name" inline="yes">
						<cases>
							<case><txt>define</txt></case>
							<case><txt>:</txt></case>
						</cases>
					</define>
					<define id="formal-macro-args">
						<nt name="formal-macro-arg"/><opt repeated="yes"><txt>,</txt><nt name="formal-macro-arg"/></opt>
					</define>
					<define id="formal-macro-arg">
						<cases>
							<case><nt name="by-val-arg"/></case>
							<case><nt name="by-ref-arg"/></case>
						</cases>
					</define>
					<define id="by-val-arg">
						<opt><nt name="type-id"/></opt><nt>ident</nt><opt><txt>=</txt><nt>expr</nt></opt>
					</define>
					<define id="by-ref-arg">
						<opt><nt name="type-id"/></opt><txt>*</txt><nt>ident</nt>
					</define>
					<define id="type-id">
						<cases>
							<case><txt>any</txt></case>
							<case><txt>int</txt></case>
							<case><txt>str</txt></case>
							<case><txt>func</txt></case>
						</cases>
					</define>
					<define id="locality" inline="yes">
						<cases>
							<case><txt>private</txt></case>
							<case><txt>protected</txt></case>
							<case><txt>public</txt></case>
						</cases>
					</define>
				</syntax>
				<description>
					<para>The first syntax ("variable-definition") defines a variable named <synel>ident</synel>, or assigns a value to an element of an array named <synel>ident</synel>. If none of the <synel>public</synel>, <synel>protected</synel>, or <synel>private</synel> keywords are specified, default <link href="visibility">visibility</link> is assumed.</para>
					<para>The second syntax ("macro-definition") defines a macro named <synel>ident</synel>. When defining a macro there must be no whitespace between macro name and opening parenthesis, otherwise it will be treated as variable declaration.</para>
					<para>The third syntax ("default-visibility-set") sets the default <link href="visibility">visibility</link> of further variable and macro definitions in this file. If no visibility declaration occurs in a file, public visibility is assumed by default.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>#define MyAppName "My Program"</line>
						<line>#define MyAppVer <link href="GetFileVersion">GetFileVersion</link>("MyProg.exe")</line>
						<line>#define MyArray[0] 15</line>
						<line>#define Multiply(int A, int B = 10) A * B</line>
					</pre>
				</section>
				<section title="See also">
					<para>&dim;, &undef;, <link href="visibility"/>.</para>
				</section>
			</topic>
			<topic id="dim">
				<title>#dim, #redim</title>
				<keywords>
          <kwd>dim</kwd>
          <kwd>redim</kwd>
        </keywords>
				<syntax>
					<define id="dim-directive">
						<txt>dim</txt><opt><nt name="locality"/></opt><nt>ident</nt><nt name="index-spec"/>
					</define>
					<define id="redim-directive">
						<txt>redim</txt><opt><nt name="locality"/></opt><nt>ident</nt><nt name="index-spec"/>
					</define>
					<define id="index-spec" inline="yes">
						<txt>[</txt><nt>expr</nt><txt>]</txt>
					</define>
				</syntax>
				<description>
					<para>Use &dim; to declare an array variable and set its dimension. All elements of the array are initialized to null (void). To assign an element value after declaring the array, use &define;. Instead of assigning element values with &define;, it is also possible to set an element value by using it as the left operand of an assignment.</para>
					<para>Use &redim; to increase or decrease the dimension of an existing array variable. All new elements of the array are initialized to null (void) and existing elements are left unchanged. Identical to &dim; if <synel>ident</synel> isn't an existing array variable.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>#dim MyArray[10]</line>
						<line>#define MyArray[0] 15</line>
						<line>#redim MyArray[20]</line>
						<line>#define MyArray[10] 30</line>
						<line>#redim MyArray[10]</line>
					</pre>
				</section>
				<section title="See also">
					<para>&define;, &undef;, <link href="DimOf"/>, <link href="visibility"/>.</para>
				</section>
			</topic>
			<topic id="undef">
				<title>#undef</title>
				<keywords><kwd>undef</kwd></keywords>
				<syntax>
					<define id="undef-directive">
						<group><nt name="undef-dir-name"/></group><opt><nt name="locality"/></opt><nt>ident</nt>
					</define>
					<define id="undef-dir-name" inline="yes">
						<cases>
							<case><txt>undef</txt></case>
							<case><txt>x</txt></case>
						</cases>
					</define>
				</syntax>
				<description>
					<para>Undefines (removes) a variable or macro. If no <link href="visibility">visibility</link> (<synel>public</synel>, <synel>protected</synel>, or <synel>private</synel>) is specified, ISPP first tries to remove a private variable of the given name, then protected, then public.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>#undef MyVar</line>
						<line>#undef MyMacro</line>
						<line>#undef public MyVar</line>
					</pre>
				</section>
				<section title="See also">
					<para>&define;, &dim;, <link href="visibility"/>.</para>
				</section>
			</topic>
			<topic id="include">
				<title>#include</title>
				<keywords><kwd>include</kwd></keywords>
				<syntax>
					<define id="include-directive">
						<variant><group><nt name="inc-dir-name"/></group><txt>&lt;</txt><nt>filename</nt><txt>&gt;</txt></variant>
						<variant><group><nt name="inc-dir-name"/></group><nt>expr</nt></variant>
					</define>
					<define id="inc-dir-name" inline="yes">
						<cases>
							<case><txt>include</txt></case>
							<case><txt>+</txt></case>
						</cases>
					</define>
				</syntax>
				<description>
					<para>Includes the &translation; of the specified file.</para>
					<para>If the filename is enclosed in angle brackets, ISPP first searches for the file in the directory where current file resides, then in the directory where the file that included current file resides, and so on. If the file is not found, it is searched on current include path, set via &pragma;, then on the path specified by INCLUDE environment variable.</para>
					<para>If filename is an expression or specified in quotes, it is searched on current include path only.</para>
          <para>The filename may be prefixed by "compiler:", in which case it looks for the file in the Compiler directory.</para>
					<para>This directive cannot be used inline.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>#include &lt;file.iss&gt;</line>
						<line>#include "c:&bs;dir&bs;file.iss"</line>
						<line>#include AddBackslash(<link href="predefinedvars">CompilerPath</link>) + "common.iss"</line>
					</pre>
				</section>
				<section title="See also">
					<para>&file;, &sub;.</para>
				</section>
			</topic>
			<topic id="file">
				<title>#file</title>
				<keywords><kwd>file</kwd></keywords>
				<syntax>
					<define id="file-directive">
						<txt>file</txt><nt>expr</nt>
					</define>
				</syntax>
				<description>
					<para>Replaces the directive with the name of a temporary file containing the &translation; of the specified file. Upon end of compilation, the temporary file is automatically deleted.</para>
					<para>Including a file using this directive creates a new independent instance of the preprocessor, passing it options currently in effect and all declared identifiers. If the included file modifies options in some way, they are not propagated back.</para>
					<para>When using this directive in Inno Setup's Source parameter of the [Files] section, specify a DestName parameter too, else the file with not be installed with the original name.</para>
					<para>This directive can only be used <link href="directives">inline</link>.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>[Setup]</line>
						<line>LicenseFile=&ob;#file "mylic.txt"&cb;</line>
					</pre>
				</section>
				<section title="See also">
					<para>&include;.</para>
				</section>
			</topic>
			<topic id="emit">
				<title>#emit</title>
				<keywords><kwd>emit</kwd></keywords>
				<syntax>
					<define id="emit-directive">
						<group><nt name="emit-dir-name"/></group><nt>expr</nt>
					</define>
					<define id="emit-dir-name" inline="yes">
						<cases>
							<case><txt>emit</txt></case>
							<case><txt>=</txt></case>
						</cases>
					</define>
				</syntax>
				<description>
					<para>Replaces the directive with the value of &expr;.</para>
					<para>When used <link href="directives">inline</link>, the name of this directive can be omitted unless &expr; begins with the name of another directive.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>[Files]</line>
						<line>#emit 'Filename: "file1.ext"; DestDir: &ob;' + MyDestDir + '&cb;'</line>
						<line>Filename: "file2.ext"; DestDir: &ob;&ob;#MyDestDir&cb;&cb;</line>
						<line>#emit GenerateVisualCppFilesEntries ; user defined macro</line>
						<line></line>
						<line>[Code]</line>
						<line>const</line>
						<line>&dsp;AppName = '&ob;#<link href="setupsetting">SetupSetting</link>("AppName")&cb;';</line>
					</pre>
				</section>
				<section title="See also">
					<para><synel><link href="expr">expr</link></synel>.</para>
				</section>
			</topic>
			<topic id="expr">
				<title>#expr</title>
				<keywords><kwd>expr</kwd></keywords>
				<syntax>
					<define id="expr-directive">
						<group><nt name="expr-dir-name"/></group><nt>expr</nt>
					</define>
					<define id="expr-dir-name" inline="yes">
						<cases>
							<case><txt>expr</txt></case>
							<case><txt>!</txt></case>
						</cases>
					</define>
				</syntax>
				<description>
					<para>Evaluates an expression ignoring its result. This directive acts like &emit; with the exception that it doesn't emit anything to the &translation;.</para>
					<para>This directive is intended to be used with functions that produce side effects and do not return any significant value.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>#expr <link href="savetofile">SaveToFile</link>(AddBackslash(SourcePath) + "Preprocessed.iss"), <link href="exec">Exec</link>(AddBackslash(CompilerPath) + "Compil32.exe", """" + AddBackslash(SourcePath) + "Preprocessed.iss""")</line>
					</pre>
				</section>
				<section title="See also">
					<para>&emit;.</para>
				</section>
			</topic>
			<topic id="insert">
				<title>#insert</title>
				<keywords><kwd>insert</kwd></keywords>
				<syntax>
					<define id="insert-directive">
						<txt>insert</txt><nt>expr</nt>
					</define>
				</syntax>
				<description>
					<para>Changes the insertion point. By default, each processed line is added to the end of the &translation;. Using &insert; the point at which the next processed line will be added to the &translation; can be changed. &insert; takes an expression which must evaluate to an integer. The insertion point will be set to this integer.</para>
					<para>The insertion point is also always automatically incremented each time after line has been added to the &translation;, so that each new line is inserted after the one previously inserted.</para>
					<para>It is not recommended to use script generating functions (such as <synel><link href="SetSetupSetting">SetSetupSetting</link></synel>) which may insert a line by themselves, thus shifting a part of the translation one line down, whereas insertion point is not updated. This may result in different insertion point than expected.</para>
					<para>The <synel><link href="find">Find</link></synel> function can be used to produce values for the &insert; directive.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>#insert FindSectionEnd("Icons")</line>
						<line>#insert FindSection("Setup") + 1</line>
						<line>#insert <link href="find">Find</link>(0, "somefile.ext", FIND_CONTAINS)</line>
					</pre>
				</section>
				<section title="See also">
					<para><synel><link href="append">append</link></synel>.</para>
				</section>
			</topic>
			<topic id="append">
				<title>#append</title>
				<keywords><kwd>append</kwd></keywords>
				<syntax>
					<define id="append-directive">
						<txt>append</txt>
					</define>
				</syntax>
				<description>
					<para>Resets the insertion point (if previously changed using &insert;) to the end of the &translation;.</para>
				</description>
				<section title="See also">
					<para>&insert;.</para>
				</section>
			</topic>
			<topic id="if">
				<title>#if, #elif, #else, #endif</title>
				<keywords>
					<kwd>if</kwd>
					<kwd>elif</kwd>
					<kwd>else</kwd>
					<kwd>endif</kwd>
				</keywords>
				<syntax>
					<define id="if-directive">
						<txt>if</txt><nt>expr</nt>
					</define>
					<define id="elif-directive">
						<txt>elif</txt><nt>expr</nt>
					</define>
					<define id="else-directive">
						<txt>else</txt>
					</define>
					<define id="endif-directive">
						<txt>endif</txt>
					</define>
				</syntax>
				<description>
					<para>The &if;, &elif;, &else;, and &endif; conditional directives control in- and exclusion of portions of script.</para>
					<para>ISPP first evaluates the expressions following each &if; or &elif; directive until it finds one evaluating to non-zero. It then selects the portion of script following this directive up to its associated &elif;, &else;, or &endif;. Earlier portions which followed an &if; or &elif; which evaluated to zero, or which follows any next &elif; are not selected and thus not seen by the Inno Setup compiler.</para>
					<para>If no expression evaluated to non-zero, the preprocessor selects the script portion after the &else; directive if present, else nothing is selected.</para>
					<para>Finally, after selecting any script portion, ISPP preprocesses it too, so if it contains other preprocessor directives, ISPP carries out those directives as well.</para>
					<para>Each &if; directive in a source file must be matched by a closing &endif; directive. Any number of &elif; directives can appear between the &if; and &endif; directives, but at most one &else; directive is allowed. The &else; directive, if present, must be the last directive before &endif;.</para>
					<para>The &if;, &elif;, &else;, and &endif; directives can be nested. Each nested &else;, &elif;, or &endif; directive belongs to the closest preceding &if; directive.</para>
					<para>Inline conditional directives may not be mixed with simple. If the &if; directive is simple (occupying a whole line), its associated directives (&elif;, &else;, or &endif;) must also be simple and not inline (appearing inside other lines).</para>
				</description>
				<section title="Examples">
					<pre>
						<line>#define Lang</line>
						<line></line>
						<line>[Tasks]</line>
						<line>#if "English" == Lang = <link href="ReadIni">ReadIni</link>(<link href="SetupSetting">SetupSetting</link>("MessagesFile"), &bs;</line>
						<line>&dsp;"LangOptions", "LanguageName")</line>
						<line>&dsp;Description: "For all users"; Name: all</line>
						<line>#elif "German" == Lang</line>
						<line>&dsp;Description: "Fur alle"; Name: all</line>
						<line>#else</line>
						<line>#&sp;error Unsupported language</line>
						<line>#endif</line>
					</pre>
				</section>
			</topic>
			<topic id="ifdef">
				<title>#ifdef, #ifndef, #ifexist, #ifnexist</title>
				<keywords>
					<kwd>ifdef</kwd>
					<kwd>ifndef</kwd>
					<kwd>ifexist</kwd>
					<kwd>ifnexist</kwd>
				</keywords>
				<syntax>
					<define id="ifdef-directive">
						<txt>ifdef</txt><nt>ident</nt>
					</define>
					<define id="ifndef-directive">
						<txt>ifndef</txt><nt>ident</nt>
					</define>
					<define id="ifexist-directive">
						<txt>ifexist</txt><nt>expr</nt>
					</define>
					<define id="ifnexist-directive">
						<txt>ifnexist</txt><nt>expr</nt>
					</define>
				</syntax>
				<description>
					<para>You can use the &ifdef;, &ifndef;, &ifexist;, and &ifnexist; directives anywhere &if; can be used. The <synel>ifdef identifier</synel> statement is equivalent to <synel>if 1</synel> when the specified identifier has been defined, and equivalent to <synel>if 0</synel> when the identifier has not been defined or has been undefined with the &undef; directive. These directives check only for the presence or absence of identifiers defined with &define;.</para>
					<para>&ifexist; and &ifnexist; directives check for presence and absence of the file, respectively.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>[Files]</line>
						<line>#ifexist "myfile.ext"</line>
						<line>&dsp;Filename: "myfile.ext"; DestDir: &ob;app&cb;</line>
						<line>#endif</line>
						<line>#ifdef Enterpise</line>
						<line>&dsp;Filename: "extra.dll"; DestDir: &ob;app&cb;</line>
						<line>#endif</line>
					</pre>
				</section>
				<section title="See also">
					<para><link href="FileExists"/></para>
				</section>
			</topic>
			<topic id="for">
				<title>#for</title>
				<keywords><kwd>for</kwd></keywords>
				<syntax>
					<define id="for-directive">
						<txt>for</txt><txt>&sp;</txt><txt>&ob;</txt><nt>expr1</nt><txt>;</txt><nt>expr2</nt><txt>;</txt><nt>expr3</nt><txt>&cb;</txt><nt>expr4</nt>
					</define>
				</syntax>
				<description>
					<para>Use the &for; directive to get loop behaviour. &for; takes 4 expressions. The first expression (<synel>expr1</synel>) is called "initialization expression," the second expression (<synel>expr2</synel>) "condition," the third expression (<synel>expr3</synel>) "action," and the final expression (<synel>expr4</synel>) "loop body."</para>
					<para>The logic the &for; directive follows is:</para>
					<para>&dsp;1. The initialization expression is evaluated.</para>
					<para>&dsp;2. The condition is evaluated. If it evaluates to 0, the loop ends.</para>
					<para>&dsp;3. The loop body is evaluated.</para>
					<para>&dsp;4. The action is evaluated.</para>
					<para>&dsp;5. Process repeats from 2.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>// Call AddFile user defined procedure 200 times</line>
						<line>#for &ob;i = 200; i &gt; 0; i--&cb; AddFile</line>
					</pre>
				</section>
				<section title="More examples">
					<para><link href="FindFirst"/>, <link href="FileRead"/>.</para>
				</section>
				<section title="See also">
					<para>&sub;, &include;.</para>
				</section>
			</topic>
			<topic id="sub">
				<title>#sub, #endsub</title>
				<keywords>
					<kwd>sub</kwd>
					<kwd>endsub</kwd>
				</keywords>
				<syntax>
					<define id="sub-directive">
						<txt>sub</txt><nt>ident</nt>
					</define>
					<define id="endsub-directive">
						<txt>endsub</txt>
					</define>
				</syntax>
				<description>
					<para>&sub; and &endsub; directives are used to declare a user defined procedure which is a portion of script which may be included later once or several times. You make think of a user defined procedure as begin similar to an external file, and a call to a user defined procedure as being similar to inclusion of an external file, except that procedures may also be called from within expressions. Please note that it is strongly not recommended to call procedures which emit several lines to &translation; from within compound expressions or directives.</para>
					<para>A procedure is called by simply specifying its identifier, with which it was declared.</para>
					<para>A procedure is not processed in any way until it is called, so if any errors exist in its body, they will only pop up when the procedure is called.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>#sub AddFile</line>
						<line>&dsp;#if <link href="Copy">Copy</link>(FileName, 1, 1) == "A"</line>
						<line>&dsp;&dsp;Source: &ob;#FileName&cb;; DestDir: &ob;app&cb;&bs;A</line>
						<line>&dsp;#else</line>
						<line>&dsp;&dsp;Source: &ob;#FileName&cb;; DestDir: &ob;app&cb;</line>
						<line>&dsp;#endif</line>
						<line>#endsub</line>
					</pre>
				</section>
				<section title="More examples">
					<para><link href="FindFirst"/>, <link href="FileRead"/>.</para>
				</section>
				<section title="See also">
					<para><link href="macros"/>, &if;, &emit;.</para>
				</section>
			</topic>
			<topic id="pragma">
				<title>#pragma</title>
				<keywords><kwd>pragma</kwd></keywords>
				<syntax>
					<define id="pragma-directive">
						<variant><nt name="pragma-option"/></variant>
						<variant><nt name="pragma-itokens"/></variant>
						<variant><nt name="pragma-msg"/></variant>
						<variant><nt name="pragma-verblev"/></variant>
						<variant><nt name="pragma-include"/></variant>
						<variant><nt name="pragma-spansymb"/></variant>
					</define>
					<define id="pragma-option">
						<txt>pragma</txt><group><nt name="opt-parseopt"/></group><nt name="option"/><opt repeated="yes"><nt name="option"/></opt>
					</define>
					<define id="opt-parseopt" inline="yes">
						<cases><case><txt>option</txt></case><case><txt>parseroption</txt></case></cases>
					</define>
					<define id="option" inline="yes">
						<txt>-</txt><nt>letter</nt><group><nt name="plusminus"/></group>
					</define>
					<define id="plusminus" inline="yes">
						<cases><case><txt>+</txt></case><case><txt>-</txt></case></cases>
					</define>
					<define id="pragma-itokens">
						<txt>pragma</txt><group><nt name="pragma-token-id"/></group><nt>expr</nt>
					</define>
					<define id="pragma-token-id" inline="yes">
						<cases><case><txt>inlinestart</txt></case><case><txt>inlineend</txt></case></cases>
					</define>
					<define id="pragma-msg">
						<txt>pragma</txt><group><nt name="pragma-msg-type"/></group><nt>expr</nt>
					</define>
					<define id="pragma-msg-type" inline="yes">
						<cases><case><txt>message</txt></case><case><txt>warning</txt></case><case><txt>error</txt></case></cases>
					</define>
					<define id="pragma-verblev">
						<txt>pragma verboselevel</txt><nt>expr</nt>
					</define>
					<define id="pragma-include">
						<txt>pragma include</txt><nt>expr</nt>
					</define>
					<define id="pragma-spansymb">
						<txt>pragma spansymbol</txt><nt>expr</nt>
					</define>
				</syntax>
				<description>
					<para>&pragma; is a special directive. Please note that if ISPP fails to parse parameters of this directive (because of typo or wrong syntax), no error will occur &dash; only a warning will be issued; this is done for compatibility with other preprocessors, which can have their own syntax of &pragma; directive.</para>
					<para>First syntax of &pragma; directive controls the options, which ISPP uses to read the source. There are two groups of options. Each group consists of 26 flags (not all of them are meaningful and used by ISPP, though). Each flag has an assigned latin letter. You specify options by typing group name (<synel>option</synel> or <synel>parseroption</synel>),
then the letter following the dash. After a letter a plus or minus sign shall be specified. Plus sign to turn the option on, minus to turn it off. Unrestricted number of options can be specified at once (see syntax).
The list of options is provided at the end of this topic.</para>
					<para>First group of options (<synel>option</synel>) controls the options of the whole ISPP engine, while second group (<synel>parseroption</synel>) controls options specific to parser. The list of options is provided at the end of this topic.</para>
					<para>Second syntax is used to specify inline directive terminators: starting and ending, respectively. After the token description keyword (<synel>inlinestart</synel> or <synel>inlineend</synel>) a string type expression must follow. It must not evaluate to an empty string. Only first seven symbols from the string are taken. It is allowed to specify the same token for both starting and ending terminators. By default, <synel>&ob;#</synel> (opening brace and a number sign) and <synel>&cb;</synel> (closing brace) are assumed.</para>
					<para>Third syntax of &pragma; directive issues a message of the type specified by the keyword following the directive name. Messages and warnings are sent to the messages window of the compiler. Errors are shown (by the compiler) using message boxes. Expression must be of type string. Also see the &error; directive.</para>
					<para>Fourth syntax sets the level of verbosity. When the verbose mode is on (see below), this syntax controls the level of importance of messages. Least important messages will show up only when highest verbose level (9) is set.</para>
					<para>Fifth syntax sets the include path. Expression may specify multiple paths delimited with semicolons. The list of these directories is used when ISPP tries to find a file, mentioned in &include; directive.</para>
					<para>The last syntax sets the symbol used to span multiple lines together. Expression must not evaluate to an empty string. Only first symbol in string is taken.</para>
				</description>
				<section title="ISPP options">
					<table>
						<tr><td>c</td><td>Indicates that the &translation; should be sent to the compiler after preprocessing is done. Default state: on.</td></tr>
						<tr><td>e</td><td>Specifies whether empty lines from the source should be emitted to the &translation;, as well as lines with ISPP directives should be replaced with empty lines. Default state: off.</td></tr>
						<tr><td>v</td><td>Turns on/off the verbose mode. Default state: off.</td></tr>
					</table>
				</section>
				<section title="Parser options">
					<table>
						<tr><td>b</td><td>Short-circuit boolean evaluation. Default state: on.</td></tr>
						<tr><td>m</td><td>Short-circuit multiplication evaluation. (In "<code>0 * A</code>", <code>A</code> will not be evaluated, since the result of expression is known to be zero.) Default state: off.</td></tr>
						<tr><td>p</td><td>Pascal-style string literals. In off state uses C-style string literals (with escape sequences). Default state: on.</td></tr>
						<tr><td>u</td><td>Allow undeclared identifiers. If an undefined identifier is encountered, ISPP will raise an error unless this option is turned on, in which case a standalone identifier (the one that does not look like a function call) will be considered void value. Default state: off.</td></tr>
					</table>
				</section>
				<section title="Examples">
					<pre>
						<line>#pragma parseroption -b- -u+</line>
						<line>#pragma option -c-</line>
						<line>#pragma warning "Variable value is: " + MyVar</line>
						<line>#pragma option -v+</line>
						<line>#pragma verboselevel 9</line>
						<line>#pragma inlinestart "$("</line>
						<line>#pragma inlineend ")"</line>
						<line>#pragma include __INCLUDE__ + ";D:&bs;INCLUDE"</line>
						<line>#pragma spansymbol "_"</line>
					</pre>
				</section>
			</topic>
			<topic id="error">
				<title>#error</title>
				<keywords><kwd>error</kwd></keywords>
				<syntax>
					<define id="error-directive">
						<txt>error</txt><nt>text</nt>
					</define>
				</syntax>
				<description>
					<para>Directive causes the Inno Setup compiler to issue an error message with the specified text. Unlike <synel>pragma error</synel>, text in <synel>error</synel> directive is not parsed, so it is recommended to use this directive instead of &pragma; when possible to avoid possible syntax errors that may hide real errors your script is trying to report.</para>
				</description>
				<section title="Examples">
					<pre>
						<line>#if <link href="predefinedvars">VER</link> &lt; EncodeVer(5,4,2)</line>
						<line>&dsp;#error A more recent version of Inno Setup is required to compile this script (5.4.2 or newer)</line>
						<line>#endif</line>
					</pre>
				</section>
				<section title="See also">
					<para>&pragma;, &if;.</para>
				</section>
			</topic>
		</topic>
		<!--   FUNCTIONS -->
		<topic id="funcs">
			<title>Functions</title>
			<description header="no">
				<para>There are a number of predefined functions provided by ISPP which you can use to perform compile-time actions and/or change your script. For example the following reads version info from an EXE and uses the return value of the function to change the script:</para>
        <pre>
          <line>#define MyAppVer GetFileVersion(AddBackslash(SourcePath) + "MyProg.exe")</line>
          <line></line>
          <line>[Setup]</line>
          <line>AppVerName=MyProg version {#MyAppVer}</line>
        </pre>
      </description>
			<subtopicstitle>Available functions</subtopicstitle>
			<topic id="GetFileVersion">
				<title>GetFileVersion</title>
				<section title="Prototype">
					<pre>
						<line><b>str</b> GetFileVersion(<b>str</b>)</line>
					</pre>
				</section>
				<description>
					<para><synel>GetFileVersion</synel> function takes a string argument which must be set to the name of the file whose version information is to be queried. The function returns string composed of four decimal numbers delimited with periods. If file does not contain valid version info, the function returns an empty string.</para>
					<para>ISPP also has <link href="GetStringFileInfo">GetStringFileInfo</link> function, which also can be used to retrieve file version (using "FileVersion" or "ProductVersion" as second parameter). The difference is that GetFileVersion takes it from fixed block of version info, unlike GetStringFileInfo, which extracts string from language specific block.</para>
				</description>
			</topic>
			<topic id="GetStringFileInfo">
				<title>GetStringFileInfo</title>
				<section title="Prototype">
					<pre>
						<line><b>str</b> GetStringFileInfo(<b>str</b> 1, <b>str</b> 2, <b>int</b>? 3)</line>
					</pre>
				</section>
				<description>
					<para><synel>GetStringFileInfo</synel> function retrieves string from specified file's (first argument) version information resource.</para>
					<para>Second argument is the name of the version info string-value. This should be one of the predefined strings. Those strings and shortcut macros are declared in &builtins;.</para>
					<para>Third optional argument should specify language and charset identifier. For example: 0x04BE0409 stands for "English (United States)." If this parameter is omitted, ISPP scans for all available version info blocks to find the value.</para>
					<para>The function returns an empty string, if it was unable to retrieve the desired string-value.</para>
				</description>
			</topic>
			<topic id="Int">
				<title>Int</title>
				<section title="Prototype">
					<pre>
						<line><b>int</b> Int(<b>any</b> 1, <b>int</b>? 2)</line>
					</pre>
				</section>
				<description>
					<para>Function converts an expression (first argument) to its integer representation. If the expression is an integer, the result of the function is the expression value. If the expression is void, the result is 0. If the expression is string, ISPP tries to convert it to integer; if such attempt fails, an error is raised unless second parameter specifies the default result.</para>
				</description>
			</topic>
			<topic id="Str">
				<title>Str</title>
				<section title="Prototype">
					<pre>
						<line><b>str</b> Str(<b>any</b>)</line>
					</pre>
				</section>
				<description>
					<para>Function converts an expression to string. If the expression is integer, the result is its string representation. If the expression is void, the result is an empty string. Otherwise the result is the value of the expression.</para>
				</description>
			</topic>
			<topic id="FileExists">
				<title>FileExists</title>
				<section title="Prototype">
					<pre>
						<line><b>int</b> FileExists(<b>str</b>)</line>
					</pre>
				</section>
				<description>
					<para>Returns non-zero value if the specified file exists.</para>
				</description>
			</topic>
			<topic id="DirExists">
				<title>DirExists</title>
				<section title="Prototype">
					<pre>
						<line><b>int</b> DirExists(<b>str</b>)</line>
					</pre>
				</section>
				<description>
					<para>Returns non-zero value if the specified directory exists.</para>
				</description>
			</topic>
			<topic id="ForceDirectories">
				<title>ForceDirectories</title>
				<section title="Prototype">
					<pre>
						<line><b>int</b> ForceDirectories(<b>str</b>)</line>
					</pre>
				</section>
				<description>
					<para>Creates all the directories along the specified directory path all at once. If the first directories in the path do exist, but the latter ones don't, ForceDirectories creates just the ones that don't exist. Returns non-zero value if successful.</para>
				</description>
			</topic>
			<topic id="FileSize">
				<title>FileSize</title>
				<section title="Prototype">
					<pre>
						<line><b>int</b> FileSize(<b>str</b>)</line>
					</pre>
				</section>
				<description>
					<para>Returns size, in bytes, of the specified file. If the file does not exist, the result is -1. Beware of ISPP supporting only signed 32 bit integers: for files larger than 2 GB (and smaller than 4 GB) the result is negative.</para>
				</description>
			</topic>
			<topic id="ReadIni">
				<title>ReadIni</title>
				<section title="Prototype">
					<pre><line><b>str</b> ReadIni(<b>str</b> 1, <b>str</b> 2, <b>str</b> 3, <b>str</b>? 4)</line></pre>
				</section>
				<description>
					<para>Reads the value from an INI file. Argument 1 must be the name of the INI file, argument 2 &dash; the name of a section in the INI file, the third argument is the key in the section to read. Last optional argument can be used to provide the default value that will be returned on failure, if it is omitted, an empty string is returned.</para>
				</description>
			</topic>
			<topic id="WriteIni">
				<title>WriteIni</title>
				<section title="Prototype">
					<pre><line><b>void</b> WriteIni(<b>str</b> 1, <b>str</b> 2, <b>str</b> 3, <b>any</b> 4)</line></pre>
				</section>
				<description>
					<para>Writes specified value to an INI file. Argument 1 is the name of the INI file, argument 2 &dash; the name of a section in the INI file, argument 3 &dash; the name of a key in the section. Last argument should be set to the value you wish to be written to the INI file, it can be of any type.</para>
				</description>
			</topic>
			<topic id="ReadReg">
				<title>ReadReg</title>
				<section title="Prototype">
					<pre><line><b>any</b> ReadReg(<b>int</b> 1, <b>str</b> 2, <b>str</b>? 3, <b>any</b>? 4)</line></pre>
				</section>
				<description>
					<para>Reads the value of the specified key in the 32-bit or 64-bit system registry. First parameter is the root key, such as HKEY_LOCAL_MACHINE (32-bit) or HKEY_LOCAL_MACHINE_64 (64-bit). Constants for use with this parameter are declared in &builtins; accompanying ISPP. Second parameter specifies a subkey. Third parameter specifies the name of the value, if this parameter is omitted, a default value is assumed. Last optional parameter may be used to specify the default value that will be returned on failure.</para>
					<para>Note that this function can return value of any type depending on the type of actual value in registry.</para>
				</description>
			</topic>
			<topic id="Exec">
				<title>Exec</title>
				<section title="Prototype">
					<pre><line><b>int</b> Exec(<b>str</b> 1, <b>str</b>? 2, <b>str</b>? 3, <b>int</b>? 4, <b>int</b>? 5)</line></pre>
				</section>
				<description>
					<para>Executes specified executable file.</para>
					<para>First argument specifies the filename of the module to execute.</para>
					<para>Second argument may be used to specify command line to execute.</para>
					<para>Third argument may be used to specify the working directory of the process.</para>
					<para>Fourth argument should be set to zero, if you don't wish to wait for the process to finish, and non-zero otherwise. By default, non-zero value is assumed.</para>
					<para>Fifth argument can be any of the <synel>SW_*</synel> constants defined in &builtins;. For GUI processes, it specifies the default value the first time ShowWindow is called. By default, SW_SHOWNORMAL (i. e. 1) is assumed.</para>
					<para>If fourth argument is omitted or is non-zero, the function returns the exit code of the process. Otherwise, the function result indicates whether the process has been successfully launched (non-zero for success).</para>
				</description>
			</topic>
			<topic id="Copy">
				<title>Copy</title>
				<section title="Prototype">
					<pre><line><b>str</b> Copy(<b>str</b> 1, <b>int</b> 2, <b>int</b>? 3)</line></pre>
				</section>
				<description>
					<para>Function extracts a substring from a string (first argument). The 1-based index of the character from which the substring should start is specified by the second argument. The third argument specifies the number of characters to take, if it is omitted, all characters up to the end of the string are copied to the result.</para>
				</description>
			</topic>
			<topic id="Pos">
				<title>Pos</title>
				<section title="Prototype">
					<pre><line><b>int</b> Pos(<b>str</b> 1, <b>str</b> 2)</line></pre>
				</section>
				<description>
					<para><synel>Pos</synel> searches for a substring (first argument) in another string (second argument) and returns an integer value that is the 1-based index of the first character of the substring within the second string. <synel>Pos</synel> is case-sensitive. If the substring is not found, <synel>Pos</synel> returns zero.</para>
				</description>
			</topic>
			<topic id="RPos">
				<title>RPos</title>
				<section title="Prototype">
					<pre><line><b>int</b> RPos(<b>str</b> 1, <b>str</b> 2)</line></pre>
				</section>
				<description>
					<para><synel>RPos</synel> searches for a substring (first argument) in another string (second argument) and returns an integer value that is the 1-based index of the first character of the last occurrence of the substring within the second string. <synel>RPos</synel> is case-sensitive. If the substring is not found, <synel>RPos</synel> returns zero.</para>
				</description>
			</topic>
			<topic id="Len">
				<title>Len</title>
				<section title="Prototype">
					<pre><line><b>int</b> Len(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Returns the length of the given string.</para>
				</description>
			</topic>
			<topic id="SaveToFile">
				<title>SaveToFile</title>
				<section title="Prototype">
					<pre><line><b>void</b> SaveToFile(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>This function saves &curtrans; to the specified file.</para>
				</description>
			</topic>
			<topic id="Find">
				<title>Find</title>
				<section title="Prototype">
					<pre><line><b>int</b> Find(<b>int</b> 1, <b>str</b> 2, <b>int</b>? 3, <b>str</b>? 4, <b>int</b>? 5, <b>str</b>? 6, <b>int</b>? 7)</line></pre>
				</section>
				<description>
					<para><synel>Find</synel> function is intended to be used with &insert; directive. Function returns the index of the line in a &translation; depending on specified criteria.</para>
					<para>First parameter denotes the index of the line to start the search from, usually it is set to zero.</para>
					<para>Second, fourth, and sixth parameters should specify string(s) to search within each line. Only the second parameter must be specified whereas fourth and sixth may be omitted.</para>
					<para>Third, fifth, and seventh parameters should specify the search flags for each string meaning that third parameter specifies flags for second, fifth for fourth, and seventh for sixth.</para>
					<para>If any of the 'flags' parameters is omitted but the string parameter preceding it is specified, <synel>FIND_MATCH | FIND_AND</synel> (i. e. 0) is assumed.</para>
					<para>Values for third, fifth, and seventh parameters of <synel>Find</synel> function are declared in &builtins;. See <link href="find-flags">Find flags</link> topic for the description of each value.</para>
				</description>
				<section title="See also">
					<para>&insert;.</para>
				</section>
				<topic id="find-flags">
					<title>Find flags</title>
					<description>
						<para>One of the following four values must be specified:</para>
						<para><synel>FIND_MATCH</synel> (0) means that the line must match the search string.</para>
						<para><synel>FIND_BEGINS</synel> (1) means that the line must start with the search string.</para>
						<para><synel>FIND_ENDS</synel> (2) means that the line must end with the search string.</para>
						<para><synel>FIND_CONTAINS</synel> (3) means that the line must contain (i. e. it also can match, begin, or end with) the search string.</para>
						<para>Any of the following modifiers may be combined with one of the previous using bitwise OR operator (<synel>|</synel>):</para>
						<para><synel>FIND_CASESENSITIVE</synel> (4) means that comparison must be case-sensitive.</para>
						<para><synel>FIND_AND</synel> (0) means that this criterium (the pair of arguments in <synel>Find</synel> function) must be met as well as previous criteria.</para>
						<para><synel>FIND_OR</synel> (8) means that it is allowed that this criterium is tested even if previous criteria were not met.</para>
						<para><synel>FIND_NOT</synel> (16) means that this criterium must not be met.</para>
						<para><synel>FIND_AND</synel> and <synel>FIND_OR</synel> are mutually exclusive. If both are specified, <synel>FIND_OR</synel> takes precedence.</para>
						<para>Special flags:</para>
						<para><synel>FIND_TRIM</synel> (32) means that leading and trailing whitespaces must be stripped off from the line prior to testing it against all the criteria. This flag can only be used in the third argument of the <synel>Find</synel> function. It is not mutually exclusive with any of the previously mentioned flags.</para>
					</description>
				</topic>
			</topic>
			<topic id="SetupSetting">
				<title>SetupSetting</title>
				<section title="Prototype">
					<pre><line><b>str</b> SetupSetting(<b>str</b>)</line></pre>
				</section>
				<description>
					<para><synel>SetupSetting</synel> function parses <extlink href="ms-its:isetup.chm::/topic_setupsection.htm">[Setup] section</extlink> in &curtrans; to find the key whose name is specified as function parameter. Function returns the value of that key if it's found, or an empty string otherwise.</para>
				</description>
			</topic>
			<topic id="SetSetupSetting">
				<title>SetSetupSetting</title>
				<section title="Prototype">
					<pre><line><b>void</b> SetSetupSetting(<b>str</b> 1, <b>str</b> 2)</line></pre>
				</section>
				<description>
					<para><synel>SetSetupSetting</synel> function modifies or generates [Setup] section directive given the key (first parameter) and its value (second parameter).</para>
					<para>If there is no [Setup] section in &curtrans; (it may happen that function is called before that section in a script), its header (as well as directive itself) is generated by this function.</para>
					<para>Please use this function carefully &dash; it should not be called when ISPP is in insert mode (i. e. after &insert; directive).</para>
				</description>
			</topic>
			<topic id="LowerCase">
				<title>LowerCase</title>
				<section title="Prototype">
					<pre><line><b>str</b> LowerCase(<b>str</b>)</line></pre>
				</section>
				<description>
					<para><synel>LowerCase</synel> returns a string with the same text as the string passed in its parameter, but with all letters converted to lowercase. The conversion affects only 7-bit ASCII characters between 'A' and 'Z'.</para>
				</description>
			</topic>
			<topic id="EntryCount">
				<title>EntryCount</title>
				<section title="Prototype">
					<pre><line><b>int</b> EntryCount(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Function returns the total number of entries in specified section in &curtrans;. It does not count empty lines or comments. Function takes care of multiple sections with the same name and counts all of them.</para>
				</description>
			</topic>
			<topic id="GetEnv">
				<title>GetEnv</title>
				<section title="Prototype">
					<pre><line><b>str</b> GetEnv(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Returns the value of the environment variable whose name is specified as the parameter. Returns empty string if variable is not defined.</para>
				</description>
			</topic>
			<topic id="DeleteFile">
				<title>DeleteFile</title>
				<section title="Prototype">
					<pre><line><b>void</b> DeleteFile(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Marks the specified file for deletion after the compilation has completed. Does not return anything. Also see <synel><link href="DeleteFileNow">DeleteFileNow</link></synel>.</para>
				</description>
			</topic>
			<topic id="DeleteFileNow">
				<title>DeleteFileNow</title>
				<section title="Prototype">
					<pre><line><b>void</b> DeleteFileNow(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Deletes the specified file. Does not return anything. Also see <synel><link href="DeleteFile">DeleteFile</link></synel>.</para>
				</description>
			</topic>
			<topic id="CopyFile">
				<title>CopyFile</title>
				<section title="Prototype">
					<pre><line><b>void</b> CopyFile(<b>str</b> 1, <b>str</b> 2)</line></pre>
				</section>
				<description>
					<para>Copies an existing file (first parameter) to a new file (second parameter). If the new file already exists, it will be overwritten.</para>
				</description>
			</topic>
			<topic id="FindFirst">
				<title>FindFirst</title>
				<section title="Prototype">
					<pre><line><b>int</b> FindFirst(<b>str</b>, <b>int</b>)</line></pre>
				</section>
				<description>
					<para><synel>FindFirst</synel> searches the directory specified by first parameter for the first file that matches the file name implied by first parameter and the attributes specified by second parameter. If the file is found, the result is a find handle, that should be used in subsequent calls to <synel><link href="FindGetFileName">FindGetFileName</link></synel>, <synel><link href="FindNext">FindNext</link></synel>, and <synel><link href="FindClose"/></synel> functions, otherwise the return value is 0.</para>
					<para>The first parameter is the directory and file name mask, including wildcard characters. For example, <synel>'.&bs;*.*'</synel> specifies all files in the current directory).</para>
					<para>The second parameter specifies the special files to include in addition to all normal files. Choose from these file attribute constants defined in &builtins; when specifying this parameter:</para>
					<table>
						<tr><td><code>faReadOnly</code></td><td>Read-only files</td></tr>
						<tr><td><code>faHidden</code></td><td>Hidden files</td></tr>
						<tr><td><code>faSysFile</code></td><td>System files</td></tr>
						<tr><td><code>faVolumeID</code></td><td>Volume ID files</td></tr>
						<tr><td><code>faDirectory</code></td><td>Directory files</td></tr>
						<tr><td><code>faArchive</code></td><td>Archive files</td></tr>
						<tr><td><code>faAnyFile</code></td><td>Any file</td></tr>
					</table>
					<para>Attributes can be combined by OR-ing their constants or values. For example, to search for read-only and hidden files in addition to normal files, pass <synel>faReadOnly | faHidden</synel> as the parameter.</para>
					<!--para><synel>FindFirst</synel> allocates resources which must be released by calling <synel>FindClose</synel>, but only if <synel>FindFirst</synel> returned non-zero value.</para-->
				</description>
				<section title="Example">
					<pre>
						<line>[Files]</line>
						<line>#define FindHandle</line>
						<line>#define FindResult</line>
						<line>#define Mask "*.pas"</line>
						<line></line>
						<line>#sub ProcessFoundFile</line>
						<line>&dsp;#define FileName FindGetFileName(FindHandle)</line>
						<line>&dsp;#if LowerCase(Copy(FileName, 1, 4)) == "ispp"</line>
						<line>&dsp;&dsp;Source: &ob;#FileName&cb;; DestDir: &ob;app&cb;&bs;ispp</line>
						<line>&dsp;#else</line>
						<line>&dsp;&dsp;Source: &ob;#FileName&cb;; DestDir: &ob;app&cb;</line>
						<line>&dsp;#endif</line>
						<line>#endsub</line>
						<line></line>
						<line>#for &ob;FindHandle = FindResult = FindFirst(Mask, 0); FindResult; FindResult = FindNext(FindHandle)&cb; ProcessFoundFile</line>
						<line>#if FindHandle</line>
						<line>&dsp;#expr FindClose(FindHandle)</line>
						<line>#endif</line>
					</pre>
				</section>
				<section title="See also">
					<para>&define;, &sub;, &if;.</para>
				</section>
			</topic>
			<topic id="FindNext">
				<title>FindNext</title>
				<section title="Prototype">
					<pre><line><b>int</b> FindNext(<b>int</b>)</line></pre>
				</section>
				<description>
					<para><synel>FindNext</synel> returns the next entry that matches the name and attributes specified in a previous call to <synel><link href="FindFirst">FindFirst</link></synel>. The parameter must be find handle returned by <synel>FindFirst</synel>. The return value is non-zero if the function was successful.</para>
				</description>
			</topic>
			<topic id="FindClose">
				<title>FindClose</title>
				<section title="Prototype">
					<pre><line><b>void</b> FindClose(<b>int</b>)</line></pre>
				</section>
				<description>
					<para><synel>FindClose</synel> terminates a <synel><link href="FindFirst">FindFirst</link></synel>/<synel><link href="FindNext">FindNext</link></synel> sequence. The parameter must be non-zero find handle returned by <synel>FindFirst</synel>.</para>
					<para>This function is obsolete since 1.2. ISPP automatically frees resources allocated in a call to <synel>FindFirst</synel>.</para>
				</description>
			</topic>
			<topic id="FindGetFileName">
				<title>FindGetFileName</title>
				<section title="Prototype">
					<pre><line><b>str</b> FindGetFileName(<b>int</b>)</line></pre>
				</section>
				<description>
					<para>Feed <synel>FindGetFileName</synel> with the find handle returned by <synel><link href="FindFirst">FindFirst</link></synel> to get the name of the file found by the last call to <synel>FindFirst</synel> or <synel><link href="FindNext">FindNext</link></synel>.</para>
				</description>
			</topic>
			<topic id="FileOpen">
				<title>FileOpen</title>
				<section title="Prototype">
					<pre><line><b>int</b> FileOpen(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>This function opens a text file for reading and returns the file handle (or zero on failure) to be used in subsequent calls to <synel>File*</synel> functions.</para>
					<!--para><synel>FileOpen</synel> allocates resources which must be released by calling <synel><link href="FileClose">FileClose</link></synel>.</para-->
				</description>
			</topic>
			<topic id="FileRead">
				<title>FileRead</title>
				<section title="Prototype">
					<pre><line><b>str</b> FileRead(<b>int</b>)</line></pre>
				</section>
				<description>
					<para>The function reads the next line in a text file opened with <synel><link href="FileOpen">FileOpen</link></synel>. The only parameter should be the file handle returned by <synel>FileOpen</synel>.</para>
				</description>
				<section title="Example">
					<pre>
						<line>#define FileHandle</line>
						<line>#define FileLine</line>
						<line>#sub ProcessFileLine</line>
						<line>&dsp;#define FileLine = FileRead(FileHandle)</line>
						<line>&dsp;#pragma message FileLine</line>
						<line>#endsub</line>
						<line>#for &ob;FileHandle = FileOpen("c:&bs;autoexec.bat"); &bs;</line>
						<line>&dsp;FileHandle &amp;&amp; !<link href="FileEof">FileEof</link>(FileHandle); ""&cb;
							&bs;</line>
						<line>&dsp;ProcessFileLine</line>
						<line>#if FileHandle</line>
						<line>&dsp;#expr <link href="FileClose">FileClose</link>(FileHandle)</line>
						<line>#endif</line>
					</pre>
				</section>
				<section title="See also">
					<para>&define;, &sub;, &pragma;, &for;, &if;.</para>
				</section>
			</topic>
			<topic id="FileReset">
				<title>FileReset</title>
				<section title="Prototype">
					<pre><line><b>void</b> FileReset(<b>int</b>)</line></pre>
				</section>
				<description>
					<para>The function resets the file pointer to zero, so the subsequent call to <synel><link href="FileRead">FileRead</link></synel> will read the first line of the file. The only parameter should be the file handle returned by <synel><link href="FileOpen">FileOpen</link></synel>.</para>
				</description>
			</topic>
			<topic id="FileEof">
				<title>FileEof</title>
				<section title="Prototype">
					<pre><line><b>int</b> FileEof(<b>int</b>)</line></pre>
				</section>
				<description>
					<para>The function returns zero if the file pointer does not point to the end of the file, or non-zero otherwise. If this function returns non-zero value, subsequent calls to <synel><link href="FileRead">FileRead</link></synel> will fail. The only parameter should be the file handle returned by <synel><link href="FileOpen">FileOpen</link></synel>.</para>
				</description>
			</topic>
			<topic id="FileClose">
				<title>FileClose</title>
				<section title="Prototype">
					<pre><line><b>void</b> FileClose(<b>int</b>)</line></pre>
				</section>
				<description>
					<para>The function closes open file and releases all resources allocated by a call to <synel><link href="FileOpen">FileOpen</link></synel>. After calling <synel>FileClose</synel>, the file handle becomes invalid.</para>
					<para>This function is obsolete since 1.2. ISPP automatically frees resources allocated in a call to <synel>FileOpen</synel>.</para>
				</description>
			</topic>
			<topic id="GetDateTimeString">
				<title>GetDateTimeString</title>
				<section title="Prototype">
					<pre><line><b>str</b> GetDateTimeString(<b>str</b>, <b>str</b>, <b>str</b>)</line></pre>
				</section>
				<description>
					<para>The function returns the current date and time as a string using the specified formatting.</para>
					<para>The first parameter is the format string. The second and third parameters denote the DateSeparator and TimeSeparator parameters explained below.</para>
					<para>The following format specifiers are supported:</para>
					<table>
						<tr><td>d</td><td>Displays the day as a number without a leading zero (1-31).</td></tr>
						<tr><td>dd</td><td>Displays the day as a number with a leading zero (01-31).</td></tr>
						<tr><td>ddd</td><td>Displays the day as an abbreviation (Sun-Sat).</td></tr>
						<tr><td>dddd</td><td>Displays the day as a full name (Sunday-Saturday).</td></tr>
						<tr><td>ddddd</td><td>Displays the date using the system's short date format.</td></tr>
						<tr><td>dddddd</td><td>Displays the date using the system's long date format.</td></tr>
						<tr><td>m</td><td>Displays the month as a number without a leading zero (1-12). If the m specifier immediately follows an h or hh specifier, the minute rather than the month is displayed.</td></tr>
						<tr><td>mm</td><td>Displays the month as a number with a leading zero (01-12). If the mm specifier immediately follows an h or hh specifier, the minute rather than the month is displayed.</td></tr>
						<tr><td>mmm</td><td>Displays the month as an abbreviation (Jan-Dec).</td></tr>
						<tr><td>mmmm</td><td>Displays the month as a full name (January-December).</td></tr>
						<tr><td>yy</td><td>Displays the year as a two-digit number (00-99).</td></tr>
						<tr><td>yyyy</td><td>Displays the year as a four-digit number (0000-9999).</td></tr>
						<tr><td>h</td><td>Displays the hour without a leading zero (0-23).</td></tr>
						<tr><td>hh</td><td>Displays the hour with a leading zero (00-23).</td></tr>
						<tr><td>n</td><td>Displays the minute without a leading zero (0-59).</td></tr>
						<tr><td>nn</td><td>Displays the minute with a leading zero (00-59).</td></tr>
						<tr><td>s</td><td>Displays the second without a leading zero (0-59).</td></tr>
						<tr><td>ss</td><td>Displays the second with a leading zero (00-59).</td></tr>
						<tr><td>t</td><td>Displays the time using the system's short time format.</td></tr>
						<tr><td>tt</td><td>Displays the time using the system's long time format.</td></tr>
						<tr><td>am/pm</td><td>Uses the 12-hour clock for the preceding h or hh specifier. Displays 'am' for any hour before noon, and 'pm' for any hour after noon. The am/pm specifier can use lower, upper, or mixed case, and the result is displayed accordingly.</td></tr>
						<tr><td>a/p</td><td>Uses the 12-hour clock for the preceding h or hh specifier. Displays 'a' for any hour before noon, and 'p' for any hour after noon. The a/p specifier can use lower, upper, or mixed case, and the result is displayed accordingly.</td></tr>
						<tr><td>/</td><td>Displays the date separator character given by the DateSeparator parameter. If DateSeparator is set to an empty string, the system's date separator character will be used instead.</td></tr>
						<tr><td>:</td><td>Displays the time separator character given by the TimeSeparator parameter. If TimeSeparator is set to an empty string, the system's time separator character will be used instead.</td></tr>
						<tr><td>'xx'/"xx"</td><td>Characters enclosed in single or double quotes are displayed as-is, and do not affect formatting.</td></tr>
					</table>
					<para>Format specifiers may be written in upper case as well as in lower case letters--both produce the same result.</para>
				</description>
				<section title="Example">
					<pre>
						<line>#define MyDateTimeString GetDateTimeString('ddddd', '', '');</line>
						<line>#define MyDateTimeString GetDateTimeString('ddddd tt', '', '');</line>
						<line>#define MyDateTimeString GetDateTimeString('dd/mm/yyyy hh:nn:ss', '-', ':');</line>
					</pre>
				</section>
			</topic>
			<topic id="GetFileDateTimeString">
				<title>GetFileDateTimeString</title>
				<section title="Prototype">
					<pre><line><b>str</b> GetFileDateTimeString(<b>str</b>, <b>str</b>, <b>str</b>, <b>str</b>)</line></pre>
				</section>
				<description>
					<para>The function returns the date and time of the specified file as a string using the specified formatting.</para>
					<para>The first parameter is the file name. The second, third and fourth parameters denote the format string, DateSeparator and TimeSeparator parameters as explained in the <link href="GetDateTimeString">GetDateTimeString</link> topic.</para>
				</description>
				<section title="Example">
					<pre>
						<line>#define MyFileDateTimeString GetFileDateTimeString('myfile.txt', 'dd/mm/yyyy hh:nn:ss', '-', ':');</line>
					</pre>
				</section>
			</topic>
			<topic id="GetMD5OfString">
				<title>GetMD5OfString</title>
				<section title="Prototype">
					<pre><line><b>str</b> GetMD5OfString(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Gets the MD5 sum of the specified ANSI string, as a string.</para>
				</description>
				<section title="Example">
					<pre>
						<line>#define MD5 GetMD5OfString('Test')</line>
						<line>// MD5 = '0cbc6611f5540bd0809a388dc95a615b'</line>
					</pre>
				</section>
			</topic>
			<topic id="GetMD5OfUnicodeString">
				<title>GetMD5OfUnicodeString</title>
				<section title="Prototype">
					<pre><line><b>str</b> GetMD5OfString(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Gets the MD5 sum of the specified Unicode string, as a string.</para>
					<para>Causes an internal error if called during non Unicode compilation.</para>
				</description>
				<section title="Example">
					<pre>
						<line>#define MD5 GetMD5OfUnicodeString('Test')</line>
						<line>// MD5 = '8e06915d5f5d4f8754f51892d884c477'</line>
					</pre>
				</section>
			</topic>
			<topic id="GetMD5OfFile">
				<title>GetMD5OfFile</title>
				<section title="Prototype">
					<pre><line><b>str</b> GetMD5OfFile(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Gets the MD5 sum of the specified file, as a string.</para>
				</description>
			</topic>
			<topic id="GetSHA1OfString">
				<title>GetSHA1OfString</title>
				<section title="Prototype">
					<pre><line><b>str</b> GetSHA1OfString(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Gets the SHA-1 hash of the specified ANSI string, as a string.</para>
				</description>
			</topic>
			<topic id="GetSHA1OfUnicodeString">
				<title>GetSHA1OfUnicodeString</title>
				<section title="Prototype">
					<pre><line><b>str</b> GetSHA1OfString(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Gets the SHA-1 hash of the specified Unicode string, as a string.</para>
					<para>Causes an internal error if called during non Unicode compilation.</para>
				</description>
			</topic>
			<topic id="GetSHA1OfFile">
				<title>GetSHA1OfFile</title>
				<section title="Prototype">
					<pre><line><b>str</b> GetSHA1OfFile(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Gets the SHA-1 hash of the specified file, as a string.</para>
				</description>
			</topic>
			<topic id="Trim">
				<title>Trim</title>
				<section title="Prototype">
					<pre><line><b>str</b> Trim(<b>str</b>)</line></pre>
				</section>
				<description>
					<para>Returns a copy of the specified string without leading and trailing spaces.</para>
				</description>
			</topic>
			<topic id="StringChange">
				<title>StringChange</title>
				<section title="Prototype">
					<pre><line><b>str</b> StringChange(<b>str</b>, <b>str</b>, <b>str</b>)</line></pre>
				</section>
				<description>
					<para>Returns a copy of the first string, with all occurrences of the second string changed to the third string.</para>
				</description>
				<section title="Example">
					<pre>
						<line>#define MyString "a ca c"</line>
						<line>#define MyString2 StringChange(MyString, " ", "b")</line>
						<line>// MyString2 = 'abcabc'</line>
					</pre>
				</section>
			</topic>
			<topic id="Defined">
				<title>Defined</title>
				<section title="Prototype">
					<pre>
						<line><b>int</b> Defined(&lt;ident&gt;)</line>
						<line><b>int</b> Defined &lt;ident&gt;</line>
					</pre>
				</section>
				<description>
					<para>Special function. Returns non-zero if the specified identifier is defined with &define; directive.</para>
					<para>Using parentheses is optional.</para>
				</description>
			</topic>
			<topic id="TypeOf">
				<title>TypeOf</title>
				<section title="Prototype">
					<pre>
						<line><b>int</b> TypeOf(&lt;ident&gt;)</line>
						<line><b>int</b> TypeOf &lt;ident&gt;</line>
					</pre>
				</section>
				<description>
					<para>Special function. Returns one of predefined TypeOf constants which are declared in &builtins; for the specified identifier.</para>
					<para>Using parentheses is optional.</para>
				</description>
			</topic>
			<topic id="DimOf">
				<title>DimOf</title>
				<section title="Prototype">
					<pre>
						<line><b>int</b> DimOf(&lt;ident&gt;)</line>
						<line><b>int</b> DimOf &lt;ident&gt;</line>
					</pre>
				</section>
				<description>
					<para>Special function. Returns the dimension of the specified identifier.</para>
					<para>Using parentheses is optional.</para>
				</description>
				<section title="See also">
					<para>&dim;, &redim;.</para>
				</section>
			</topic>
			<topic id="ParseVersion">
				<title>ParseVersion</title>
				<section title="ParseVersion">
					<pre>
						<line>#define ParseVersion(str FileName, *Major, *Minor, *Rev, *Build)</line>
					</pre>
				</section>
				<description>
					<para>Calls the <synel><link href="GetFileVersion">GetFileVersion</link></synel> function and parses the string returned by that function (in form "0.0.0.0"). All four version elements are stored in by-reference parameters Major, Minor, Rev, and Build. Returns the string returned by GetFileVersion.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="EncodeVer">
				<title>EncodeVer</title>
				<section title="EncodeVer">
					<pre>
						<line>#define EncodeVer(int Major, int Minor, int Revision = 0, int Build = -1)</line>
					</pre>
				</section>
				<description>
					<para>Returns given four version elements encoded to a 32 bit integer number (8 bits for each element, i.e. elements must be within 0...255 range).</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="DecodeVer">
				<title>DecodeVer</title>
				<section title="DecodeVer">
					<pre>
						<line>#define DecodeVer(int Ver, int Digits = 3)</line>
					</pre>
				</section>
				<description>
					<para>Returns given 32 bit integer encoded version decoded to its string representation. The Digits parameter indicates how many elements to show (if the fourth element is 0, it won't be shown anyway).</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="FindSection">
				<title>FindSection</title>
				<section title="FindSection">
					<pre>
						<line>#define FindSection(str Section = "Files")</line>
					</pre>
				</section>
				<description>
					<para>Returns the index of the line following the header of the section. This macro is intended to be used with &insert; directive.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="FindSectionEnd">
				<title>FindSectionEnd</title>
				<section title="FindSectionEnd">
					<pre>
						<line>#define FindSectionEnd(str Section = "Files")</line>
					</pre>
				</section>
				<description>
					<para>Returns the index of the line following last entry of the section. This macro is intended to be used with #insert directive.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="FindCode">
				<title>FindCode</title>
				<section title="FindCode">
					<pre>
						<line>#define FindCode()</line>
					</pre>
				</section>
				<description>
					<para>Returns the index of the line following either the [Code] section header, or the "program" keyword, if any.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="ExtractFilePath">
				<title>ExtractFilePath</title>
				<section title="ExtractFilePath">
					<pre>
						<line>#define ExtractFilePath(str PathName)</line>
					</pre>
				</section>
				<description>
					<para>Returns the directory portion of the given filename with a backslash. If PathName doesn't contain a directory portion, the result is an empty string.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="ExtractFileDir">
				<title>ExtractFileDir</title>
				<section title="ExtractFileDir">
					<pre>
						<line>#define ExtractFileDir(str PathName)</line>
					</pre>
				</section>
				<description>
					<para>Returns the directory portion of the given filename without a backslash (unless it is a root directory). If PathName doesn't contain a directory portion, the result is an empty string.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="ExtractFileExt">
				<title>ExtractFileExt</title>
				<section title="ExtractFileExt">
					<pre>
						<line>#define ExtractFileExt(str PathName)</line>
					</pre>
				</section>
				<description>
					<para>Returns the extension portion of the given filename, NOT including the period character.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="ExtractFileName">
				<title>ExtractFileName</title>
				<section title="ExtractFileName">
					<pre>
						<line>#define ExtractFileName(str PathName)</line>
					</pre>
				</section>
				<description>
					<para>Returns the name portion of the given filename. If PathName ends with a backslash, the result is an empty string.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="ChangeFileExt">
				<title>ChangeFileExt</title>
				<section title="ChangeFileExt">
					<pre>
						<line>#define ChangeFileExt(str FileName, str NewExt)</line>
					</pre>
				</section>
				<description>
					<para>Changes the extension in FileName with NewExt. NewExt must not contain period.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="RemoveFileExt">
				<title>RemoveFileExt</title>
				<section title="RemoveFileExt">
					<pre>
						<line>#define RemoveFileExt(str FileName)</line>
					</pre>
				</section>
				<description>
					<para>Removes the extension in FileName.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="AddBackslash">
				<title>AddBackslash</title>
				<section title="AddBackslash">
					<pre>
						<line>#define AddBackslash(str S)</line>
					</pre>
				</section>
				<description>
					<para>Appends a backslash to the string, if it's not already there.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="RemoveBackslash">
				<title>RemoveBackslash</title>
				<section title="RemoveBackslash">
					<pre>
						<line>#define RemoveBackslash(str S)</line>
					</pre>
				</section>
				<description>
					<para>Removes the trailing backslash from the string unless the string points to a root directory.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="Delete">
				<title>Delete</title>
				<section title="Delete">
					<pre>
						<line>#define Delete(str *S, int Index, int Count = MaxInt)</line>
					</pre>
				</section>
				<description>
					<para>Deletes the specified number of characters beginning with Index from S. S is passed by reference (therefore is modified).</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="Insert2">
				<title>Insert</title>
				<section title="Insert">
					<pre>
						<line>#define Insert(str *S, int Index, str Substr)</line>
					</pre>
				</section>
				<description>
					<para>Inserts specified Substr at Index'th character into S. S is passed by reference (therefore is modified).</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="YesNo">
				<title>YesNo</title>
				<section title="YesNo">
					<pre>
						<line>#define YesNo(str S)</line>
					</pre>
				</section>
				<description>
					<para>Returns nonzero value if given string is "yes", "true" or "1". Intended to be used with the <synel><link href="SetupSetting">SetupSetting</link></synel> function.</para>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="Power">
				<title>Power</title>
				<section title="Power">
					<pre>
						<line>#define Power(int X, int P = 2)</line>
					</pre>
				</section>
				<description>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="Min">
				<title>Min</title>
				<section title="Min">
					<pre>
						<line>#define Min(int A, int B, int C = MaxInt)</line>
					</pre>
				</section>
				<description>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
			<topic id="Max">
				<title>Max</title>
				<section title="Max">
					<pre>
						<line>#define Max(int A, int B, int C = MinInt)</line>
					</pre>
				</section>
				<description>
          <para>Declared in &builtins;.</para>
				</description>
			</topic>
		</topic>
		<topic id="predefinedvars">
			<title>Predefined Variables</title>
			<description header="no">
				<para>There are a number of predefined variables provided ISPP:</para>
				<table>
					<tr><td><code>__COUNTER__</code></td><td><code><b>int</b></code>. Automatically increments each time it is used (afterwards).</td></tr>
					<tr><td><code>__FILE__</code></td><td><code><b>str</b></code>. Returns the name of the current file. Empty string for the root file.</td></tr>
					<tr><td><code>__INCLUDE__</code></td><td><code><b>str</b></code>. Returns the current include path (or paths delimited with semicolons) set via <code>#pragma include</code>.</td></tr>
					<tr><td><code>__LINE__</code></td><td><code><b>int</b></code>. Returns the number of the line in the current file (not a &translation;) on which the variable is used (or macro that uses this variable is called).</td></tr>
					<tr><td><code>__OPT_X__</code></td><td><code><b>void</b></code>. Defined if specified option set via <code>#pragma option -x+</code> is in effect. In place of "X" may be any letter from "A" to "Z." Use <link href="defined">Defined</link> function to test whether the variable is defined.</td></tr>
					<tr><td><code>__PATHFILENAME__</code></td><td><code><b>str</b></code>. Similar to __FILE__ but, returns the full pathname of the file. Empty string for the root file.</td></tr>
					<tr><td><code>__POPT_X__</code></td><td><code><b>void</b></code>. Defined if specified parser option set via <code>#pragma parseroption -x+</code> is in effect. In place of "X" may be any letter from "A" to "Z." Use <link href="defined">Defined</link> function to test whether the variable is defined.</td></tr>
					<tr><td><code>__WIN32__</code></td><td><code><b>void</b></code>. Always defined.</td></tr>
					<tr><td><code>ISPP_INVOKED</code></td><td><code><b>void</b></code>. Always defined.</td></tr>
					<tr><td><code>PREPROCVER</code></td><td><code><b>int</b></code>. Returns the 32-bit encoded version of ISPP. Highest byte holds the major version, lowest byte holds the build number.</td></tr>
					<tr><td><code>WINDOWS</code></td><td><code><b>void</b></code>. Always defined.</td></tr>
					<tr><td><code>UNICODE</code></td><td><code><b>void</b></code>. Always defined for Unicode ISPP. Use <link href="defined">Defined</link> function to test whether the variable is defined.</td></tr>
					<tr><td><code>CompilerPath</code></td><td><code><b>str</b></code>. Points to the directory where the compiler is located.</td></tr>
					<tr><td><code>SourcePath</code></td><td><code><b>str</b></code>. Points to the directory where the current script is located, or the My Documents directory if the script has not yet been saved.</td></tr>
					<tr><td><code>Ver</code></td><td><code><b>int</b></code>. Returns the 32-bit encoded version of Inno Setup compiler. Highest byte holds the major version, lowest byte usually holds zero.</td></tr>
				</table>
			</description>
		</topic>
    <topic id="linespan">
      <title>Line Spanning</title>
      <description header="no">
        <para>By ending lines with ISPP's line spanning symbol preceded with a space, you can split long lines. For example:</para>
        <pre>
          <line>#define MyAppName &bs;</line>
          <line>&dsp;"My Program"</line>
        </pre>
        <para>The default line spanning symbol is "&bs;" which can be changed using &pragma;.</para>
      </description>
    </topic>
    <topic id="example">
      <title>Example Script</title>
      <description header="no">
        <para>An example script called <i>ISPPExample1.iss</i> is located in a separate folder. Please click the "Inno Setup Example Scripts" shortcut created in the Start Menu when you installed Inno Setup, or open the "Examples" folder in your Inno Setup directory.</para>
        <para>Also see &builtins;.</para>
      </description>
    </topic>
    <topic id="macros">
			<keywords>
				<kwd>#define</kwd>
				<kwd>define</kwd>
				<kwd>macros</kwd>
			</keywords>
			<title>User Defined Macros</title>
			<description header="no">
				<para>You can define so called "macros" in your scripts, these can be thought of as "user defined functions."</para>
				<para>Macro declaration consists of formal parameter list and expression. That expression is evaluated when macro is called (see below). The result of the macro call is the result of the macro expression. Macro expression can contain parameter names, they are treated as usual variables.</para>
				<para>The formal syntax of macro declaration is provided in &define; and the &builtins; contains many example macros.</para>
          <para>Please note that there must be no space between macro name and opening parenthesis.</para>
				<para>Actual parameters for parameters declared as by-reference must be modifiable l-values (in other words, other defined variables or expressions that evaluate to l-values). If macro expression modifies by-reference parameter, the variable that is passed as this parameter gets modified. By-value parameters can also be modified by macro expression (using assignment operators), but this modification doesn't affect the value of a variable which could be passed as this parameter.</para>
				<para>Though macro can only contain one expression, it can be used as full featured user defined function, because ISPP supports sequential evaluation operator (comma), assignment operators (simple and compound) and conditional operator (<synel>?:</synel>).</para>
      </description>
			<subtopicstitle>See also</subtopicstitle>
			<topic id="localarray">
				<title>Macros' Local array</title>
				<description header="no">
					<para>In context of macro expression additional array named <synel>Local</synel> is valid. Its elements can be used for temporary storage and reusing values in sequential expressions. This array belongs to one context of macro call, that means that values stored in <synel>Local</synel> array are neither preserved from call to call (including recursive), nor are they accessible from anywhere except the macro expression.</para>
					<pre>
						<line>#define DeleteToFirstPeriod(str *S) /* macro declaration */ &bs;</line>
						<line>&dsp;Local[1] = <link href="copy">Copy</link>(S, 1, (Local[0] = <link href="pos">Pos</link>(".", S)) - 1), &bs;</line>
						<line>&dsp;S = Copy(S, Local[0] + 1), &bs;</line>
						<line>&dsp;Local[1]</line>
					</pre>
				</description>
			</topic>
		</topic>
		<topic id="builtinsiss">
			<title>ISPPBuiltins.iss</title>
			<description header="no">
				<para>The ISPPBuiltins.iss file is accompanying the Inno Setup Preprocessor. It is automatically included, if it exists in the compiler directory, as if the very first line of your script contained an &include; directive for it. This file contains common declarations, such as special constants for using with functions, and some useful macros. The file is a regular Inno Setup Script file but mostly contains only ISPP directives.</para>
        <para>To learn more about the functionality provided by this file please open it with the Inno Setup Compiler, it is well commented.</para>
			</description>
		</topic>
		<topic id="visibility">
			<keywords>
				<kwd>private</kwd>
				<kwd>protected</kwd>
				<kwd>public</kwd>
				<kwd>visibility</kwd>
			</keywords>
			<title>Visibility of Identifiers</title>
			<description header="no">
				<para>Variables (as well as macros, read "variable or macro" anywhere it says "variable" below) can be explicitly defined as "public," "protected," or "private." To define such a variable, its name in its &define; directive should be prepended with one of the visibility keywords:</para>
				<pre>
					<line>#define public MyVar 12</line>
					<line>#define protected MyVar 13</line>
					<line>#define private MyVar 14</line>
				</pre>
				<para>In the example above, none of the last two declarations undefine any of the previous, though they share the same identifier (<synel>MyVar</synel>). This is because they are declared in different visibilities.</para>
				<para>Public variables are ordinary variables accessible from anywhere after the point they are declared.</para>
				<para>Protected variables are accessible only in the file they are declared in and in files included by that file via &include; or &file; directives. You can basically think of them as public variables which are automatically undefined once their file has finished.</para>
				<para>Private variables are accessible only in the file they are declared in. They are not propagated to any other file, be it included or "parent" file.</para>
				<para>Since ISPP does not have semantics of pushing and popping variable value, visibility resolution can be useful.</para>
				<para>Note that you cannot explicitly refer to a variable in a specific visibility from expressions. Given the example above, if <synel>MyVar</synel> is mentioned in expression in declaration file, its identifier refers to private <synel>MyVar</synel>. If it is mentioned in included file, it refers to protected <synel>MyVar</synel>. If it is mentioned in one of the files above the declaration file on the include stack (i. e. one of the files from which a chain of &include; directives resulted in processing the declaration file), it refers to public <synel>MyVar</synel>.</para>
				<para>Also note, that if we'd swap last two declarations from the above example, private <synel>MyVar</synel> would become inaccessible (until protected is undefined) because protected would be declared after it and would take precedence. But it wouldn't undefine its private counterpart.</para>
				<para>Each file can set a default visibility, the visibility that will be used when no resolution clause is specified in variable declaration. This can be done using &define; directive, for example:</para>
				<pre><line>#define protected</line></pre>
				<para>sets protected visibility by default.</para>
				<para>The default visibility isn't used when evaluating expressions, it is only used when a variable is defined or undefined without explicitly specifying its visibility. When default visibility is not set, public is assumed by default. Setting default visibility is not propagated on included or parent files.</para>
				<para>In macro expressions, avoid using identifiers of lower visibility than the one macro is declared in. This may cause "Undeclared identifier" errors if macro is called from another file.</para>
				<para>It is recommended that you use appropriate visibility when declaring variables to avoid problems with unexpected redefinition of a variable (for example in included third-party file). If no included files depend on a variable, declare it as private. If they do, but the parent file doesn't, declare it as protected. Declare it as public otherwise. If you're unsure, then protected visibility is the common case.</para>
			</description>
		</topic>
		<!--   EXPRESSIONS -->
		<topic id="expressions">
      <keywords>
        <kwd>Comments</kwd>
      </keywords>
      <title>Expression Syntax</title>
			<description header="no">
				<para>ISPP uses C/C++-like expression syntax. It supports simple and compound assignment operators, conditional operator, and sequential evaluation operator. Although ISPP is an interpreter, it does support short circuit boolean evaluation and never evaluates expressions (nor calls any macros mentioned in those expressions) that should not be evaluated due to specific rules (for example, when conditional operator is used, always only 2 out of 3 operands are evaluated).</para>
        <para>The &builtins; contains many example expressions.</para>
			</description>
			<section title="Differences between C and ISPP expression syntax">
				<ul>
					<li>ISPP does not support a number of operators (reference, dereference, namespace resolution, member selection, etc.).</li>
					<li>ISPP treats an identifier and the equality sign as a name of an argument, if it is used in argument list.</li>
					<li>Arithmetic division operator (slash) performs integer division, since ISPP does not support floating point math.</li>
					<li>ISPP does not check for validity of expressions is certain cases. For example, in conditional expression, "true" operand can be of string type, whereas "false" operand can be of integer type.</li>
					<li>String literals can be quoted by both single and double quotes (in both modes &dash; C-style or Pascal-style). If a literal begins with a single quote, it must also end with a single quote. Double quotes may be used in single quoted string without any escaping, and vice versa. Within a string the character used to quote the string must be escaped (the manner depends on current state of "Pascal-style string literals" parser option, see &pragma;).</li>
				</ul>
			</section>
			<section title="Data types">
				<para>There are three types in ISPP: void, integer, and string. Variable of void type is declared by just specifying its name after &define; directive without any value. Such variables should be used with &ifdef; directive or <synel><link href="Defined">Defined</link></synel> function.</para>
				<para>If "allow undeclared identifiers" parser option is off (the default state, see &pragma;), an error is raised when undefined variable is mentioned. Otherwise, it will be treated as a value of type void.</para>
				<para>Void is compatible with integer and string in expressions. For example, you can use addition operator with void and integer operands, in this case void operand will be treated as zero. In conjunction with string, void operand is treated as an empty string.</para>
			</section>
			<section title="Comments">
				<para>Comments may be embedded in expression by using a slash and an asterisk. For example:</para>
				<pre>
					<line>#emit Var1 /* this is a comment */ + Var2 /* this is a comment */</line>
				</pre>
				<para>Also one line comments are supported. Those comments must begin with a semicolon. Whole text after the semicolon up to the end of a line is considered comment.</para>
				<pre>
					<line>#emit Var1 + Var2 ; this is a comment</line>
				</pre>
				<para>Please note that line spanning feature is triggered before any further processing, thus a comment may occupy more than one line:</para>
				<pre>
					<line>#emit Var1 + Var2 ; this is &bs;</line>
					<line>&dsp;a comment</line>
				</pre>
			</section>
			<section title="Extended Macro Call Syntax">
				<para>In ISPP it is possible to use named arguments when calling user defined macro. Given the declaration:</para>
				<pre>
					<line>#define MyMacro(int A = 2, int B = 2) A + B</line>
				</pre>
				<para>This macro can be called specifying argument names:</para>
				<pre>
					<line>#emit MyMacro(A = 5, B = 10)</line>
					<line>#emit MyMacro(B = 3)</line>
					<line>#emit MyMacro(B = 10, A = 5)</line>
				</pre>
				<ul>
					<li>If a name is specified for one argument, then all (required) arguments in the list must also be named.</li>
					<li>The order of named arguments does not matter.</li>
					<li>
						<para>Because of this extension, an assignment expression must be enclosed in parentheses, if not using extended call syntax, to avoid ambiguity:</para>
						<pre>
							<line>#emit MyMacro((MyVar = 5), 10)</line>
						</pre>
						<para>In the above example, the equality sign is treated as a direct assignment operator.</para>
						<para>Although functions do not have named arguments, it is still required to enclose assignment expressions in parentheses when calling those functions.</para>
					</li>
					<li>
						<para>By standard rule comma is used to separate actual parameters. If you need to use sequential evaluation operator, you must include the expression in parentheses:</para>
						<pre>
							<line>#emit MyMacro((SaveToFile("script.txt"), 5), 10)</line>
						</pre>
						<para>In the above example, the first comma is treated as the sequential evaluation operator, whereas the second one as the argument delimiter.</para>
					</li>
				</ul>
			</section>
		</topic>
		<topic id="isppcc">
			<title>Extended Command Line Compiler</title>
			<description header="no">
				<para>Inno Setup Preprocessor replaces the standard Inno Setup Command Line Compiler (ISCC.exe) by an extended version. This extended version provides extra parameters to control Inno Setup Preprocessor.</para>
				<para>Usage: <synel>iscc [options] scriptfile.iss</synel>. Or to read from standard input: <synel>iscc [options] -</synel>.</para>
				<para>Options are to emulate a <link href="define">define</link> or <link href="pragma">pragma</link> directive are:</para>
				<table>
					<tr><td><code>/d&lt;name&gt;[=&lt;value&gt;]</code></td><td>Sets <code>#define public &lt;name&gt; &lt;value&gt;</code></td></tr>
					<tr><td><code>/$&lt;letter&gt;(+|-)</code></td><td>Sets <code>#pragma option -&lt;letter&gt;(+|-)</code></td></tr>
					<tr><td><code>/p&lt;letter&gt;(+|-)</code></td><td>Sets <code>#pragma parseroption -&lt;letter&gt;(+|-)</code></td></tr>
					<tr><td><code>/i&lt;paths&gt;</code></td><td>Sets <code>#pragma include -&lt;paths&gt;</code></td></tr>
					<tr><td><code>/{#&lt;string&gt;</code></td><td>Sets <code>#pragma inlinestart -&lt;string&gt;</code></td></tr>
					<tr><td><code>/}&lt;string&gt;</code></td><td>Sets <code>#pragma inlineend -&lt;string&gt;</code></td></tr>
					<tr><td><code>/v&lt;number&gt;</code></td><td>Sets <code>#pragma verboselevel -&lt;number&gt;</code></td></tr>
				</table>
				<para>Other valid options are: "/O" to specify an output path (overriding any OutputDir setting in the script), "/F" to specify an output filename (overriding any OutputBaseFilename setting in the script), and "/Q[p]" for quiet compile (print only error messages, "p" will show progress info).</para>
				<para>Example: <synel>iscc /$c- /pu+ "/dLic=Trial Lic.txt" /iC:\INC;D:\INC "c:\isetup\samples\my script.iss"</synel></para>
				<para>ISCC will return an exit code of 0 if the compile was successful, 1 if the command line parameters were invalid or an internal error occurred, or 2 if the compile failed.</para>
			</description>
		</topic>
		<topic id="translation" popup="yes">
			<title>Translation</title>
			<description header="no">
				<para>Translation refers to the preprocessed script.</para>
			</description>
		</topic>
		<topic id="current-translation" popup="yes">
			<title>Current translation</title>
			<description header="no">
				<para>Current <link href="translation" popup="yes">translation</link> refers to current output of ISPP, the translated (preprocessed) part of the script up to the point (or line) which ISPP is currently processing.</para>
			</description>
		</topic>
		<!--topic id="tricks">
  <title>Secondary ISPP features</title>
  <description header="no">
    <para>Since ISPP is not a script engine, many useful language constructs are not supported directly. But some results can be achieved using existing features of ISPP.</para>
  </description>
  <topic id="looping">
    <title>Looping</title>
    <description header="no">
      <para>ISPP allows you to call macro recursively, i. e. call it from itself. This feature can be used to emulate loop.</para>
      <para>For example, you wish to construct a "for"-like loop. To achieve this, you'll need to declare a macro that takes one integer argument and which makes the loop "body." After that you declare "outer" loop, which used for iterating:</para>
      <pre> 
        <line>#define LoopBody(int I) Str(I) + "th iteration&bs;n"</line>
        <line></line>
        <line>#define Loop(int LoopRoof = 10) &bs; </line>
        <line>&dsp;LoopRoof ?&sp;&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;/* if LoopTop is not zero */ &bs;</line>
        <line>&dsp;&dsp;LoopBody(LoopRoof) +&sp;/* call the body */ &bs; </line>
        <line>&dsp;&dsp;Loop(LoopRoof - 1)&sp;&dsp;/* next iteration*/ &bs;</line>
        <line>&dsp;:&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;/* else */ &bs;</line>
        <line>&dsp;&dsp;""&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;&dsp;&sp;/* return empty string */</line>
      </pre>
      <para>With these two macros declared, this command:</para>
      <pre>
        <line>#emit Loop(LoopRoof = 5)</line>
      </pre>
      <para>will produce</para>
      <pre>
        <line>5th iteration</line>
        <line>4th iteration</line>
        <line>3th iteration</line>
        <line>2th iteration</line>
        <line>1th iteration</line>
      </pre>
      <para>Note that this example emits text to translation, therefore it should use concatenation operator (<synel>+</synel>) with loop body and next iteration. If the loop body does not produce any output, it is recommended to use sequential evaluation operator (<synel>,</synel> - comma).</para>
    </description>
  </topic>
</topic-->
	</topic>
</yasyx>
